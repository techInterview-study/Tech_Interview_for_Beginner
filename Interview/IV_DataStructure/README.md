## 목차

- [1. 🎤 Stack & Queue](#-stack--queue)
- [2. 🎤 Array & ArrayList](#-array--arraylist)
- [3. 🎤 Bubble & Selection & Insertion Sort](#-bubble--selection--insertion-sort)
- [4. 🎤 Quick & Merge & Heap Sort](#-quick--merge--heap-sort)
- [5. 🎤 Graph](#-graph)
- [6. 🎤 Tree](#-tree)
- [7. 🎤 Binary Search Tree](#-binary-search-tree)
- [8. 🎤 Red Black Tree](#-red-black-tree)
- [9. 🎤 Encryption Algorithm](#-encryption-algorithm)
- [10. 🎤 Heap](#-heap)
- [11. 🎤 Hash Table](#-hash-table) <br/><br/>

## <span style="color: #FFA500">**🎤 Stack & Queue**</span>

**Q. 스택과 큐에 대해서 간략하게 설명해주세요.**

A. **스택(Stack)** 은 선형 자료구조의 일종으로 후입선출 즉, **Last In First Out (LIFO)** - 나중에 들어간 원소가 먼저 나오는 형태로 데이터를 저장하는 자료구조 입니다.  

**큐(Queue)는** 선형 자료구조의 일종으로 선입선출 즉, **First In First Out (FIFO)** - 먼저 들어간 원소가 먼저 나오는 형태로 데이터를 저장하는 자료구조 입니다.  <br/><br/>

**Q. 스택을 ArrayList로 구현하는 것과 배열로 구현할 때의 장단점을 말해주세요.**

A. 만약, 스택의 크기가 자주 변하고 요소의 추가/제거가 빈번하게 발생하는 경우에는 `ArrayList`를 사용하는 것이 좋습니다. 하지만, 스택의 크기가 고정되어 있고 요소의 추가/제거가 적은 경우에는 기본 배열을 사용하는 것이 더 효율적입니다.

- **ArrayList (리스트):**

**장점 :**

1. 동적으로 크기를 조정할 수 있어서 요소를 추가하거나 제거하는 데 편리하다.

**단점 :**

1. 리스트는 특정 인덱스에 있는 요소에 접근하는 것이 배열보다 비효율적입니다. <br/><br/>

- **기본 배열 (Array):**

**장점 :**

1. 배열은 요소를 저장하기 위한 공간만 할당하면 되기 때문에 메모리 소비가 상대적으로 적습니다.

**단점 :**

1. 크기를 동적으로 조정할 수 없어서 요소를 추가할 때 배열을 재할당해야 하거나 큰 배열로 복사해야 한다. <br/><br/>

**Q. Stack<> s = new Stack<>(); 이 가능하지만 Queue<> q = new Queue<>(); 가 안되는 이유에 대해서 말씀해주세요.**

A. Java에서는 `Stack` 클래스가 이미 구현되어 있어서 `new Stack<>()`와 같이 사용할 수 있습니다. 하지만 `Queue와 Map` 은 인터페이스로 제공되며, 인터페이스는 직접 인스턴스화할 수 없습니다. 즉, `new Queue<>()`와 같은 코드는 컴파일되지 않습니다. 

대신, `Queue`를 구현하는 클래스들 중 하나인 `LinkedList` 구현체를 이용하여 Queue를 만들 수 있습니다. <br/><br/>

## <span style="color: #FFA500">🎤 Array & ArrayList</span>

**Q. Array와 LinkedList의 장/단점에 대해 설명해주세요.**

A. 

### **Array (배열)**

**장점:**

1. **Random Access**: 인덱스를 통한 랜덤 액세스가 매우 빠릅니다. 즉, 특정 위치의 요소를 상수 시간에 접근할 수 있습니다.
2. **메모리 효율성**: 연속된 메모리 공간에 요소들을 저장하기 때문에 메모리 효율적입니다. <br/><br/>

**단점:**

1. **크기 제한**: 배열은 정적으로 할당되기 때문에 크기가 고정되어 있어 동적으로 크기를 조정하기 어렵습니다.
2. **삽입/삭제 비효율성**: 중간에 요소를 삽입하거나 삭제할 경우, 이후의 요소들을 이동시켜야 하므로 시간이 많이 소요될 수 있습니다.
3. **메모리 낭비**: 배열은 요소의 개수와 관계없이 고정된 크기를 가지기 때문에 실제 사용되지 않는 메모리가 낭비될 수 있습니다. 

### **LinkedList (연결 리스트)**

**장점:**

1. **동적 크기 조정**: 연결 리스트는 동적으로 크기를 조정할 수 있기 때문에 삽입 및 삭제 작업이 효율적입니다.
2. **메모리 절약**: 필요한 만큼의 노드만 동적으로 할당되므로 메모리를 절약할 수 있습니다. <br/><br/>

**단점:**

1. **Random Access의 부족**: 특정 인덱스의 요소에 접근하기 위해선 처음부터 순차적으로 접근해야 하므로 접근 시간이 더 오래 걸립니다. 즉, 랜덤 액세스가 비효율적입니다.
2. **메모리 비효율성**: 각각의 노드는 자신의 데이터와 다음 노드를 가리키는 링크를 저장하기 위한 추가적인 메모리가 필요합니다. <br/><br/>

**Q. Array와 LinkedList의 차이를 설명해주세요.**

A. Array는 연속된 메모리 공간을 사용하고, Linked List는 연속되지 않은 메모리 공간을 사용합니다.
그래서 Array의 경우, index를 통해 각 요소에 접근할 수 있고, 탐색에 필요한 시간복잡도는 O(1)입니다. -> 정확히는 찾고자 하는 값의 index를 알 경우 O(1)이고, 특정 값을 탐색하는것은 결국엔 배열을 다 뒤져야하는것이기 때문에 O(n)입니다

하지만 삽입이나 삭제의 경우에는 shift에 필요한 연산이 발생하여 O(n)의 시간복잡도를 가집니다. -> 정확히는 삽입 삭제의 경우 배열을 복사하는 과정이 필요하기 때문에 O(n)입니다.

반면 Linked List의 경우, shift가 필요없고, 노드 간의 연결을 이어주고 끊어주는 과정을 통해 삽입과 삭제를 O(1) 시간복잡도로 수행합니다. 탐색은 O(n) 시간복잡도로 수행합니다.

정리하면, 배열은 접근이 빈번하지만 삽입과 삭제가 드문 경우에 유용하며, 연결 리스트는 삽입과 삭제가 빈번하지만 접근이 드문 경우에 유용합니다. 이러한 특성을 고려하여 각각의 자료구조를 선택하면 됩니다. <br/><br/>

**Q. list와 set의 차이점**

A. 리스트는 순서가 있고 중복을 허용하며 변경 가능한 자료구조이며, 집합은 순서가 없고 중복을 허용하지 않는 자료구조입니다. 집합은 주로 고유한 요소들의 집합을 관리하거나 집합 연산을 수행할 때 사용됩니다. <br/><br/>

**Q. 어떻게 사용해야 하는가?**

A. **`List`** 인터페이스를 구현하는 다양한 클래스들, 예를 들어**`ArrayList와`** **`LinkedList`**로 구현할 수 있다. 

**`Set`** 인터페이스를 구현하는 몇 가지 주요 클래스 **`HashSet`**, **`TreeSet`**, **`LinkedHashSet`** 등으로 구현할 수 있다. <br/><br/>

## <span style="color: #FFA500">**🎤 Bubble & Selection & Insertion Sort**</span>

**Q. 버블 정렬의 정의와 장단점에 대해 말해주세요.**

A. Bubble Sort는 서로 인접한 두 원소의 대소를 비교하고, 조건에 맞지 않다면 자리를 교환하며 정렬하는 알고리즘 입니다.

- 장점
    - 구현이 매우 간단하다.
    - 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않다. => 제자리 정렬(in-place sorting)
- 단점
    - 시간복잡도가 최악, 최선, 평균 모두 O(n^2)으로, 굉장히 비효율적이다.
    - 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 한다.
    - 특히 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환되는 일이 일어난다. <br/><br/>

**Q. 버블 정렬이 단순함에도 불구하고 쓰이지 않는 이유를 시간복잡도와 관련해서 설명해주세요.**

A. 일반적으로 자료의 교환 작업(SWAP)이 자료의 이동 작업(MOVE)보다 더 복잡하기 때문에 버블 정렬은 단순성에도 불구하고 거의 쓰이지 않는다. <br/><br/>

**Q. 선택 정렬의 정의와 장단점에 대해 말해주세요.**

A. 선택 정렬은 정렬되지 않은 데이터들에 대해 가장 작은 데이터를 찾아 각 단계의 가장 앞 데이터와 교환해나가는 방식입니다. 

- 장점
    - Bubble sort와 마찬가지로 알고리즘이 단순하다.
    - Bubble Sort와 마찬가지로 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다. => 제자리 정렬(in-place sorting)
    - 정렬을 위한 비교 횟수는 많지만, Bubble Sort에 비해 실제로 교환하는 횟수는 적기 때문에 많은 교환이 일어나야 하는 자료상태에서 비교적 효율적이다.
- 단점
    - 시간복잡도가 최악, 최선, 평균 모두 O(n^2)으로, 비효율적이다.
    - 불안정 정렬이다. <br/><br/>

**Q. 선택 정렬과 버블 정렬의 차이점을 말해주세요. (선택 정렬과 버블 정렬은 시간복잡도가 같은데 runtime이 빠른 이유와 관련하여 설명해주세여)**

A. 버블 정렬에 비해 교환되는 횟수가 적기 때문에 시간복잡도는 동일하지만 runTime이 더 빠르게 나옵니다. <br/><br/>

**Q. 삽입 정렬의 정의와 장단점에 대해 말해주세요.**

A. 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교 하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘 입니다.

- 장점
    - 알고리즘이 단순하다.
    - 대부분의 원소가 이미 정렬되어 있는 경우, 매우 효율적일 수 있다.
    - 정렬하고자 하는 배열 안에서 교환하는 방식이므로, 다른 메모리 공간을 필요로 하지 않는다. => 제자리 정렬(in-place sorting)
    - Selection Sort나 Bubble Sort과 같은 O(n^2) 알고리즘에 비교하여 상대적으로 빠르다.
- 단점
    - 평균과 최악의 시간복잡도가 O(n^2)으로 비효율적이다. (다만 최선의 경우 O(n))
    - Bubble Sort와 Selection Sort와 마찬가지로, 배열의 길이가 길어질수록 비효율적이다. <br/><br/>

**Q. 삽입 정렬이 merge나 quick sort보다 빠른 상황이 어느 상황인지 설명하고, 그 이유에 대해서 설명해주세요.**

A. in-place 정렬의 경우, 연속된 메모리를 한 번 받아 더 이상 메모리를 할당 받는 일이 없습니다. 반면 in-place 정렬이 아닌 퀵이나 합병 정렬의 경우, 새로운 메모리를 계속 할당 받는데, 이러한 메모리들은 연속적이지 않아 지역성이 좋지 못합니다. 

이러한 in-place 정렬의 공간 지역성 덕분에, Insertion 정렬의 경우 소수의 원소들을 정렬할 때 merge나 quick보다 더 좋은 성능을 보이는 경우가 있습니다. <br/><br/>

## <span style="color: #FFA500">**🎤 Quick & Merge & Heap Sort**</span>

**Q. 힙 정렬(Heap Sort)에 대해 설명해주세요.**

A. 힙 정렬(Heap Sort)은 선택 정렬(Selection Sort) 알고리즘의 개선된 형태로, 힙(Heap) 자료구조를 이용하여 정렬을 수행하는 정렬 알고리즘입니다. 기본적으로 최대 힙을 사용하고 정렬과정을 반복하면서 최댓값을 배열의 가장 마지막 요소와 교환하며 정렬을 수행합니다. <br/><br/>

**Q. 병합 정렬(Merge Sort)에 대해 설명해주세요.**

A. 병합 정렬(Merge Sort)은 분할 정복(Divide and Conquer) 방식을 사용하는 비교 기반 정렬 알고리즘입니다. 병합 정렬은 배열을 두 개의 동일한 크기의 하위 배열로 분할한 다음, 하위 배열을 정렬한 후 다시 병합하는 과정을 통해 정렬을 수행합니다. 병합 정렬은 안정적이며, 빠르게 작동하므로 큰 데이터 셋에 적합한 알고리즘입니다. <br/><br/>

**Q. 퀵 정렬(Quick Sort)에 대해 설명해주세요.**

A. Quick Sort은 **분할 정복(divide and conquer) 방법** 을 통해 주진 배열을 정렬합니다. Quick Sort은 불안정 정렬에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다. 또한 Merge Sort와 달리 Quick Sort는 배열을 비균등하게 분할합니다. <br/><br/>

**Q. Sorting Algorithm에서 stable 하다는 것은 무엇을 의미하나요?**

A. 안정 정렬은 기준 값이 같을 때 기존의 순서대로 유지되는 것을 보장한다는 의미입니다. <br/><br/>

**Q. 힙정렬 병합정렬 퀵정렬의 장단점에 대해 설명해주세요.**

A. 

### 퀵 정렬

### 장점

1. 평균적으로 빠르다: 퀵 정렬은 평균적으로 O(nlogn)
2. 내부 정렬: 추가적인 메모리 없이 정렬이 가능한 내부 정렬 알고리즘. 따라서 추가적인 메모리 요구량이 거의 없다.

### 단점

1. 최악의 경우 시간 복잡도: 만약 입력 데이터가 이미 정렬되어 있거나, 역순으로 정렬되어 있는 경우, 퀵 정렬의 시간 복잡도는 O(n2)
2. 불안정한 정렬
3. 피벗 선택에 민감: 큰 영향을 미쳐 최악의 성능을 피하기 위해서는 피벗 선택 전략이 중요

### 병합 정렬

### 장점

1. 안정 정렬
2. 외부 정렬: 큰 데이터 집합에 특히 유용한 외부 정렬에서도 효과적으로 사용. 외부 정렬은 디스크와 같은 외부 저장소에 저장된 대량의 데이터를 정렬할 때 사용.
3. 시간 복잡도: 모든 경우에 대해 O(n log n)의 시간 복잡도. 큰 데이터 세트에 대해 매우 효율적입.

### 단점

1. 공간 복잡도: 병합 정렬은 O(n)의 추가 메모리를 요구.
2. 최선, 평균, 최악의 경우 시간 복잡도가 동일: 병합 정렬은 최선, 평균, 최악의 경우 모두 O(n log n)의 시간 복잡도를 가지기 때문에 다양한 상황에서의 최적화가 제한적.

### 힙 정렬

### 장점

1. 시간 복잡도: 힙 정렬의 최악, 평균, 최선의 시간 복잡도는 모두 O(n log n)입니다. 따라서 입력 데이터의 크기에 상관없이 일정한 성능을 보장.
2. 메모리 사용: 힙 정렬은 정렬을 위해 추가적인 메모리(즉, 인플레이스 정렬)를 필요로 하지 않는다.

### 단점

1. 불안정 정렬 : 따라서 동일한 값의 원소 간의 상대적 순서가 중요한 경우에는 다른 정렬 알고리즘을 고려해야함. <br/><br/>

## <span style="color: #FFA500">🎤 Graph</span>

**Q. 그래프 자료구조란?**

A. 그래프는 정점(node 또는 vertex)과 간선(edge)로 이루어진 자료구조이다.
(+사실 트리는 그래프의 일종이다. 하지만, 그래프는 트리와 달리 정점마다 간선이 존재하지 않을 수도 있으며, 루트 노드와 부모 노드, 자식 노드 개념이 존재하지 않는다.)

그래프는 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조이다. 그래서 그래프는 실생활에서 지하철 노선도 최단 경로, 도로, 선수 과목 등에 쓰이고 있다. <br/><br/>

**Q. 그래프 구현에서 인접 행렬과 인접 리스트의 장단점**

A. 인접 행렬은 연결되어 있지 않은 간선의 값도 저장해놓기에 메모리 낭비가 있다. 반면에 인접 리스트는 필요한 값들만 저장하기 때문에 그런 메모리 낭비는 없는 편이다. 반대로 특정 간선을 찾을 때, 즉 두 노드가 연결되어 있는지 파악할 때에는 인접 행렬이 더 효율적이다. <br/><br/>

**Q. 그래프 탐색이란 무엇인가요**

A. 탐색이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정을 말한다. 그래프에서의 탐색은 하나의 노드를 시작으로 다수의 노드를 방문하여 원하는 노드를 찾는 과정을 말한다. 탐색 방법에는 DFS와 BFS가 있다. <br/><br/>

**Q. 그래프 탐색 방법에 대해 말해주세요**

A. DFS는 깊이 우선 탐색 이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다. DFS는 후입 선출의 자료구조인 스택 (혹은 재귀 함수)를 이용하여 구현할 수 있다. 

기본 원리는 정점을 처음 방문할 때 스택에 삽입하고, 해당 스택에서 방문할 수 있는 vertex를 탐색하며 방문한 다음에, 방문할 수 있는 vertex가 더이상 존재하지 않을 때 스택에서 제거해주는 것이다. 구현에서는 스택 자료구조를 직접 이용해줄 수도 있고, 재귀 호출을 통해 스택을 간접적으로 사용해줄 수도 있다. BFS에 비해 저장공간의 필요성이 적고, 찾아야 할 노드가 깊은 단계에 있을 수록 유리하다.

BFS 는 너비 우선 탐색이라고도 부르며, 그래프에서 가까운 노드부터 우선적으로 탐색하는 알고리즘이다. BFS를 구현하기 위해서는 Queue를 이용할 수 있다. 대상이 무방향 그래프라고 가정할 때, 기본 원리는 정점을 처음으로 방문할 때 큐에 삽입하고, 큐에정점을 하나씩 Dequeue 하면서 그에 인접한 정점들을 큐로 삽입하는 식으로 진행한다. 이는 큐가 빌 때까지 지속하며, 새로운 원소를 큐에 삽입할 때에는 이미 방문한 정점이 아닌 경우에만 삽입해 준다. 세상의 모든 사람이 지닌 친분관계를 그래프로 나타냈을 때, 특정인 A와 B 사이 간선의 최단 경로를 구할 때 사용해줄 수 있다. <br/><br/>

**Q. BFS와 DFS의 장단점은?**

A.

### DFS 장점

- 현 경로상의 노드를 기억하기 때문에 적은 메모리를 사용합니다.
- 찾으려는 노드가 깊은 단계에 있는 경우 BFS 보다 빠르게 찾을 수 있습니다.

### DFS 단점

- 해가 없는 경로를 탐색 할 경우 단계가 끝날 때까지 탐색합니다. 효율성을 높이기 위해서 미리 지정한 임의 깊이까지만 탐색하고 해를 발견하지 못하면 빠져나와 다른 경로를 탐색하는 방법을 사용합니다.
- DFS를 통해서 얻어진 해가 최단 경로라는 보장이 없습니다. DFS는 해에 도착하면 탐색을 종료하기 때문입니다.

### BFS 장점

- 답이 되는 경로가 여러 개인 경우에도 최단경로임을 보장한다.
- 최단 경로가 존재하면 깊이가 무한정 깊어진다고 해도 답을 찾을 수 있다.

### BFS 단점

- 경로가 매우 길 경우에는 탐색 가지가 급격히 증가함에 따라 보다 많은 기억 공간을 필요로 하게 된다.
- 해가 존재하지 않는다면 유한 그래프(finite graph)의 경우에는 모든 그래프를 탐색한 후에 실패로 끝난다.
- 무한 그래프(infinite graph)의 경우에는 결코 해를 찾지도 못하고, 끝내지도 못한다. <br/><br/>

**Q. 그래프의 최단 경로 구하는 방법은?**

A. BFS를 통해서 인접한 노드들을 탐색하면 최단 경로를 구할 수 있다. <br/><br/>

## <span style="color: #FFA500">🎤 Tree</span>

Q. 그래프와 트리의 차이에 대해 설명해주세요

A. 루트와 부모-자식 관계, 방향성, 순환 구조의 허용 여부등이 다릅니다. 이러한 차이점으로 인해 그래프와 트리는 서로 다른 용도와 특성을 갖습니다. 그래프는 네트워크 모델링, 그래프 알고리즘, 경로 탐색 등 다양한 분야에서 사용되며, 트리는 계층적 데이터 구조를 표현하거나 검색 및 정렬 알고리즘에서 사용됩니다. <br/><br/>

Q. 트리의 깊이와 높이의 차이에 대해 설명해주세요

A. 

1. **깊이(Depth)**:
    - 트리의 깊이는 루트 노드로부터 어떤 노드까지의 경로의 길이를 의미합니다.
    - 즉, 특정 노드의 깊이는 해당 노드까지의 경로에 포함된 에지(Edge)의 수입니다.
    - 루트 노드의 깊이는 0이며, 자식 노드로 내려갈수록 깊이가 1씩 증가합니다.
2. **높이(Height)**:
    - 트리의 높이는 트리의 루트 노드로부터 가장 깊은 리프 노드까지의 최장 경로의 길이를 의미합니다.
    - 즉, 트리의 높이는 트리 내의 최대 깊이와 같습니다.
    - 트리의 높이는 0부터 시작하여 가장 깊은 리프 노드까지의 경로에 포함된 에지의 수를 나타냅니다. <br/><br/>

## <span style="color: #FFA500">🎤 Binary Search Tree</span>

Q. Binary Search Tree와 Binary Tree에 대해 설명해주세요.

A. 이진 트리는 자식 노드가 최대 두 개인 노드들로 구성된 트리이고, 이진 탐색 트리(Binary Search Tree)는 모든 왼쪽 자식의 값이 루트나 부모보다 작고, 모든 오른쪽 자식의 값이 루트나 부모보다 큰 값을 가진다. 또한, 이진탐색트리는 이진 탐색과 연결리스트의 장점을 고안하기 위해 만들어졌으며, 이진 탐색의 효율적인 탐색 능력을 유지하면서도 빈번한 자료 입력과 삭제가 가능하기 위해 사용된다. <br/><br/>

Q. 이진 탐색 트리의 시간 복잡도는 얼마이고 왜그런지 설명해주세요.

A. 삽입과 검색의 평균 시간 복잡도는 왼쪽과 오른쪽 중 하나 즉, 전부를 탐색할 필요없이 반만 탐색하면 되기 때문에 평균적으로 O(log n)으로 표현하지만 최악의 경우 편향되었을 때 링크드리스트와 같은 O(n)을 보여준다. 

삭제의 경우는 좀 특이하게 3가지의 경우에 대해서 시간복잡도가 다르게 나타납니다. 

1. 삭제할 노드가 말단 노드인 경우(자식노드가 없는 경우)
2. 삭제할 노드의 자식 노드가 1개인 경우
3. 삭제할 노드의 자식 노드가 2개인 경우

삭제의 경우 삭제할 대상을 검색하는 시간복잡도 + 지우거나 참조값만 붙이는 시간복잡도의 덧셈으로 이루어지는데 최악의 경우 검색이 O(n)이고, 3번의 경우 대체 노드를 찾기위해 서브트리를 탐색하는 시간복잡도 O(n)을 합쳐 O(n)이지만 평균의 경우는 삽입 검색과 같은 시간복잡도를 가진다. <br/><br/>

Q. Binary Search Tree의 규칙에 대해 설명해주세요.

A. 

1. **노드의 값**: 각 노드는 한 개의 값만을 가집니다.
2. **왼쪽 서브트리의 값**: 특정 노드의 왼쪽 서브트리에 있는 모든 노드의 값은 해당 노드의 값보다 작습니다.
3. **오른쪽 서브트리의 값**: 특정 노드의 오른쪽 서브트리에 있는 모든 노드의 값은 해당 노드의 값보다 큽니다.
4. **중복된 값은 허용되지 않음**: 동일한 값을 가진 노드가 허용되지 않습니다. <br/><br/>

Q. Binary Search Tree의 해결방법은 무엇인지 설명해주세요.

A. Binary Search Tree(BST)의 주요 문제는 트리가 균형을 잃어 성능이 저하되는 것이고, 이러한 문제를 해결하기 위한 자가 균형 트리(Self-balancing Tree)는 트리의 균형을 유지하기 위해 자동으로 회전, 재조정 등의 연산을 수행하는 트리입니다. AVL 트리, 레드-블랙 트리 등이 이러한 자가 균형 트리의 대표적인 예시입니다. <br/><br/>

Q. self balancing Binary Search Tree가 무엇인지 설명해주세요.

A. Binary Search Tree(BST)의 주요 문제는 트리가 균형을 잃어 성능이 저하되는 것이고, 이러한 문제를 해결하기 위한 자가 균형 트리(Self-balancing Tree)는 트리의 균형을 유지하기 위해 자동으로 회전, 재조정 등의 연산을 수행하는 트리입니다. AVL 트리, 레드-블랙 트리 등이 이러한 자가 균형 트리의 대표적인 예시입니다. <br/><br/>

Q. 트리의 순회 방식에는 어떤게 있는지 설명해주세요.

A. 대표적인 트리 순회 방식으로는 전위 순회(pre-order traversal), 중위 순회(in-order traversal), 후위 순회(post-order traversal)가 있습니다. 

1. **전위 순회(Pre-order Traversal)**:
    - 노드를 방문하는 순서: 루트 -> 왼쪽 서브트리 -> 오른쪽 서브트리
    - 주로 노드를 생성하거나 복사하는 경우에 사용됩니다.
2. **중위 순회(In-order Traversal)**:
    - 노드를 방문하는 순서: 왼쪽 서브트리 -> 루트 -> 오른쪽 서브트리
    - BST에서 노드의 값들을 정렬된 순서로 출력하는 데 사용됩니다.
3. **후위 순회(Post-order Traversal)**:
    - 노드를 방문하는 순서: 왼쪽 서브트리 -> 오른쪽 서브트리 -> 루트
    - 트리의 높이를 구하는 데 사용됩니다. <br/><br/>

Q. AVL 트리란 무엇인지 설명해주세요

A. AVL 트리는 균형 잡힌 이진 탐색 트리(Binary Search Tree)의 일종으로, 각 노드의 왼쪽 서브트리와 오른쪽 서브트리의 높이 차이(높이 균형 인수, balance factor)가 항상 -1, 0, 1로 유지되는 트리입니다. 이러한 균형 조건을 만족시키기 위해 삽입, 삭제 연산 시에 트리를 재조정합니다. <br/><br/>

## <span style="color: #FFA500">🎤 Red Black Tree</span>

Q.  **RB Tree란 무엇인가요?**

A. RB 트리(Red-Black Tree)는 이진 탐색 트리의 일종으로, 각 노드가 추가적인 색상 속성을 가지며, 이 속성들이 트리의 균형을 유지하는 데 사용됩니다. <br/><br/> 

Q. **RB Tree의 작동 원리는 어떻게 되나요? (5가지 필수 속성)**

A.

1. **모든 노드는 red / black 의 색을 갖는다.**
2. **root 노드는 black이다.**
3. **모든 NIL 노드는 black이다. (null은 black으로 간주)**
4. **모든 red는 black 자식을 갖는다. (red가 연속적으로 존재할 수 없다.)**
5. **임의의 노드에서 자손 nil노드들까지 향하는 모든 경로는 모두 같은 수의 black 노드가 존재한다.(자기 자신은 count 제외)** <br/><br/>

Q.  **RB Tree의 시간 복잡도는 어떻게 되나요?**

A. 탐색, 입력, 삭제에 O(logN)의 시간이 걸립니다. <br/><br/>

Q. **다른 이진 탐색 트리 알고리즘들과 비교했을 때, 어떤 장점이 있나요?**

A. Worst Case에서도 O(logN)의 탐색 시간으로 탐색하기 위해서는 자가 균형 이진 트리가 필요합니다. 자가 균형 이진 트리의 종류는 대표적으로 레드블랙 트리, AVL 트리가 있습니다. - AVL 트리는 레드블랙 트리보다 더 엄격하게 균형이 잡혀있기 때문에, 삽입과 삭제를 할 때 최악의 경우 더 많은 회전(rotation)을 필요로 합니다. 레드 블랙 트리는 실 사용에 효율적이고, 최악의 경우에도 우수한 실행 시간을 보입니다.  n개의 노드가 있을 때 O(logN)의 시간복잡도로 삽입, 삭제, 검색을 할 수 있는 장점이 있습니다. <br/><br/>

## <span style="color: #FFA500">🎤 Encryption Algorithm</span>

Q. 단방향 암호화에 대해서 간단히 설명해주세요.

A. 평문을 암호화하는 것은 가능하지만 암호문을 평문으로 복호화할 수 없는 기법 <br/><br/>

Q. 양방향 암호화에 대해서 간단히 설명해주세요.

A. 암호문을 평문으로 복호화할 수 있는 기법 <br/><br/>

Q. 대칭키와 비대칭키 암호화 방식에 대해 설명해주세요

A. 

### 대칭키

- 암/복호화에 동일한 키를 사용하는 방식
- 키(Secret Key:)가 노출되면 안 되기 때문에 비공개키라고도 한다.
- ex) SEED, AES

### 비대칭키

- 암/복호화에 다른 키를 사용하는 방식
- 노출시켜서는 안 되는 Private Key, 노출시켜도 상관 없는 Public Key
    - Private Key는 데이터를 중요하게 다루어야 하는 서버에서 사용
    - 누구나 사용해야 하는 클라이언트 측에서 Public Key 사용
- ex) RSA <br/><br/>

## <span style="color: #FFA500">🎤 Heap</span>

**Q. Heap이란 무엇이며, Max Heap과 Min Heap의 차이는 무엇인가요?**

A. 힙(Heap)은 완전 이진 트리(Complete Binary Tree)를 기반으로 한 자료구조로, 이진 힙은 보통 배열로 구현되며, 특히 우선순위 큐와 같은 자료구조에서 주로 사용됩니다.

Max Heap과 Min Heap의 차이는 부모 노드와 자식 노드 간의 값의 대소 관계입니다. Max Heap은 최대값이 루트에 위치하고, Min Heap은 최소값이 루트에 위치합니다. <br/><br/>

**Q. Heap 자료 구조는 어떤 상황에서 유용하게 사용될 수 있나요?**

A. Max Heap과 Min Heap의 특성은 힙에서 우선순위 큐를 구현하는 데 사용되며, 특히 최대값 또는 최소값을 빠르게 찾아야 하는 경우에 유용하게 활용됩니다. <br/><br/>

**Q. Heap에서 Element를 추가하거나, 삭제할 때 내부적으로 어떤 과정이 일어나는지 설명해주세요.**

A.

1. **요소 추가 (Insertion)**:
    - 일반적으로 Heap은 완전 이진 트리로 구현되며, 새로운 요소는 항상 트리의 마지막 노드에 추가됩니다.
    - 새로운 요소가 추가된 후에는 부모 노드와 비교하여 힙의 조건을 만족시키도록 위치를 조정합니다. 만약 Max Heap일 경우에는 부모 노드보다 크거나 같은 값을 가지도록 조정하고, Min Heap일 경우에는 부모 노드보다 작거나 같은 값을 가지도록 조정합니다.
    - 이 과정을 힙의 루트까지 반복하여 힙의 조건을 만족시킵니다.
2. **요소 삭제 (Deletion)**:
    - 힙에서 삭제는 일반적으로 루트 노드를 제거하는 것입니다.
    - Max Heap의 경우에는 루트 노드를 제거한 후에 마지막 노드를 루트로 옮기고 자식 노드들과 비교하여 자식 노드들 중 더 큰 값과 위치를 교환하여 힙의 조건을 만족시킵니다. Min Heap의 경우에는 루트 노드를 제거한 후에 마지막 노드를 루트로 옮기고 자식 노드들과 비교하여 자식 노드들 중 더 작은 값과 위치를 교환하여 힙의 조건을 만족시킵니다.
    - 이 과정을 힙의 루트에서부터 아래로 내려가면서 반복하여 힙의 조건을 유지합니다. <br/><br/>

**Q. Heap과 관련된 시간 복잡도에 관하여 설명해주세요. (Heap Sort & Build Heap)**

A. 

Heap과 관련된 시간 복잡도는 주로 두 가지 연산에 따라 결정됩니다: 힙을 구성하는데 필요한 시간 복잡도와 힙을 정렬하는데 필요한 시간 복잡도입니다.

힙을 재배열할 때 사용하는 **heapify()** 연산은 **O(log n)**의 시간 복잡도를 가집니다. 그 이유는 heapify()가 힙의 높이만큼 재귀 호출을 하기 때문인데요. 예를 들어, 자식 노드가 최대 2개인 힙에서 전체 노드의 개수가 n이고, h가 힙의 높이라면 n이 4일 때 h는 2가 되고, n이 8일 때 h는 3이 됩니다. 즉, 이를 계산 식으로 표현하면 높이 h = logn가 됩니다. 따라서 heapify()의 시간 복잡도는 O(log n)가 됩니다.

힙을 구축하는 **build_heap()**은 일반적으로 O(n)의 시간복잡도를 가집니다. Bottom-up 방식을 사용하여 노드의 수에 비례하는 연산 횟수로 힙을 구축할 수 있습니다. 이는 각 노드에 대해 상수 시간 연산을 수행하고, 힙의 높이에 비례하는 수의 노드가 있기 때문에 전체적으로 O(n)의 시간 복잡도를 가집니다.

따라서 Heap Sort의 전체 시간 복잡도는 O(nlogn)입니다. 이는 힙을 구성하는 단계(O(n))와 요소를 하나씩 제거하면서 힙의 성질을 유지하는 연산(logn)을 모든 요소에 대해 수행하는 것이기 때문입니다. <br/><br/>

**Q. Heap과 Binary Search Tree는 어떻게 다른가요?**

A. 모두 이진 트리(Binary Tree)를 기반으로 한 자료구조이지만 힙은 일반적으로 부모 노드와 자식 노드 간의 상대적인 크기에 기반하여 구성되는 반면 이진 탐색 트리는 각 노드의 값이 왼쪽 서브트리의 모든 값보다 크고 오른쪽 서브트리의 모든 값보다 작습니다.

또한, 탐색 방법에서도 힙은 보통 최대값 또는 최소값을 빠르게 찾기 위해 사용됩니다. 이진 탐색이 아닌 상대적인 크기에 따라 노드를 정렬하여 힙의 성질을 유지합니다. 이진 탐색 트리는 루트 노드부터 시작하여 탐색 대상 값을 현재 노드와 비교하고, 대상 값이 현재 노드보다 작으면 왼쪽 서브트리를, 크면 오른쪽 서브트리를 탐색합니다. <br/><br/>

## <span style="color: #FFA500">🎤 Hash Table</span>

Q. 해시 테이블이란 무엇인지 간단히 설명해주세요

A. 해시 테이블(Hash Table)은 키-값 쌍을 저장하고 검색하는 데 사용되는 자료구조입니다. 해시 테이블은 해시 함수를 사용하여 각 키를 해시값으로 변환하고, 이 해시값을 인덱스로 사용하여 값을 저장하거나 검색합니다. <br/><br/>

Q. 해시 함수의 기능과 중요성을 설명해주세요

A. 해시 함수는 데이터 검색 및 관리에서 중요한 역할을 합니다. 좋은 해시 함수는 데이터 구조의 성능을 향상시키고 충돌을 최소화하여 효율적인 데이터 관리를 가능하게 합니다. <br/><br/>

Q. 해시 충돌이란 무엇이며 그 해결방법에 대해 설명해주세요

A. 변환이 이루어진 후 변환된 값이 중복되는 경우가 발생할 수 있는데 이를 **해시충돌(Hash Collision)** 이라고 하고, 해시 충돌을 해결할 수 있는 방법에는 대표적으로 체이닝(Seperating Chaining), 개방 주소법(Open Addressing)이 있습니다. <br/><br/>

Q. 해시 테이블의 시간 복잡도에 대해서 설명해주세요

A. 해시 테이블은 탐색에 특화 된 자료구조로 탐색 시 평균 O(1)의 시간 복잡도를 갖는다. 이는 배열에서 index를 아는 상태에서의 접근하는 것과 동일한 시간 복잡도를 보인다.

하지만 주의해야 할 것은평균 O(1)이라는 시간 복잡도는 해시 충돌이 일어나지 않는 이상적인 상황을 고려한 것이다.해시 충돌이 일어날 수록 시간 복잡도는 최악인 O(N)에 수렴한다. 만약 수정된 Chaining방식을 이용하여 해시 충돌된 엔트리들을 Red-Black Tree로 연결한다면 최악의 경우라도 O(logN) (밑은 2)의 시간복잡도를 갖게 된다. <br/><br/>

Q. 해시 맵과 해시 테이블의 차이점에 대해 설명해주세요

A. 

◈ Thread-safe 여부

- Hashtable은 Thread-safe 하고, HashMap은 Thread-safe 하지 않다는 특징을 가지고 있다.

◈ Null 값 허용 여부

- Hashtable은 key에 null을 허용하지 않지만, HashMap은 key에 null을 허용한다.